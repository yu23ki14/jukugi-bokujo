/**
 * Agent management API routes (OpenAPI)
 */

import { createRoute, OpenAPIHono, z } from "@hono/zod-openapi";
import { MAX_ACTIVE_AGENTS_PER_USER, MAX_AGENTS_PER_USER } from "../config/constants";
import { clerkAuth, getAuthUserId } from "../middleware/clerk-auth";
import {
	CreateAgentRequestSchema,
	CreateAgentResponseSchema,
	GetAgentResponseSchema,
	ListAgentsResponseSchema,
	UpdateAgentRequestSchema,
	UpdateAgentResponseSchema,
	UpdateAgentStatusRequestSchema,
	UpdateAgentStatusResponseSchema,
} from "../schemas/agents";
import { ErrorResponseSchema, SuccessResponseSchema } from "../schemas/common";
import { generateInitialPersona } from "../services/llm";
import type { Bindings } from "../types/bindings";
import type { Agent, AgentStatus } from "../types/database";
import { getOrCreateUser, parseAgentPersona, stringifyAgentPersona } from "../utils/database";
import { conflict, forbidden, handleDatabaseError, notFound } from "../utils/errors";
import { getCurrentTimestamp } from "../utils/timestamp";
import { generateUUID } from "../utils/uuid";

const agents = new OpenAPIHono<{ Bindings: Bindings }>();

// Apply authentication to all routes
agents.use("/*", clerkAuth);

// ============================================================================
// POST /api/agents - Create new agent
// ============================================================================

const createAgentRoute = createRoute({
	method: "post",
	path: "/",
	tags: ["Agents"],
	summary: "Create a new agent",
	description: "Create a new AI agent with an initial persona generated by LLM",
	security: [{ bearerAuth: [] }],
	request: {
		body: {
			content: {
				"application/json": {
					schema: CreateAgentRequestSchema,
				},
			},
		},
	},
	responses: {
		201: {
			description: "Agent created successfully",
			content: {
				"application/json": {
					schema: CreateAgentResponseSchema,
				},
			},
		},
		400: {
			description: "Validation error",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		401: {
			description: "Unauthorized",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		409: {
			description: "Agent limit reached",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		500: {
			description: "Internal server error",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
	},
});

agents.openapi(createAgentRoute, async (c) => {
	const userId = getAuthUserId(c);
	const body = c.req.valid("json");

	console.log("Create agent request body:", JSON.stringify(body));

	try {
		// Ensure user exists in database
		await getOrCreateUser(c.env.DB, userId);

		// Check agent limit
		const countResult = await c.env.DB.prepare(
			"SELECT COUNT(*) as count FROM agents WHERE user_id = ?",
		)
			.bind(userId)
			.first<{ count: number }>();

		if (countResult && countResult.count >= MAX_AGENTS_PER_USER) {
			return conflict(c, `エージェントは最大${MAX_AGENTS_PER_USER}体までです`);
		}

		// Determine status: active if slots available, otherwise reserve
		const activeCountResult = await c.env.DB.prepare(
			"SELECT COUNT(*) as count FROM agents WHERE user_id = ? AND status = 'active'",
		)
			.bind(userId)
			.first<{ count: number }>();
		const activeCount = activeCountResult?.count ?? 0;
		const status: AgentStatus = activeCount < MAX_ACTIVE_AGENTS_PER_USER ? "active" : "reserve";

		// Generate initial persona using LLM
		const persona = await generateInitialPersona(c.env, body.name.trim(), body.values);

		// Create agent
		const agentId = generateUUID();
		const now = getCurrentTimestamp();

		await c.env.DB.prepare(
			`INSERT INTO agents (id, user_id, name, persona, status, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
		)
			.bind(agentId, userId, body.name.trim(), stringifyAgentPersona(persona), status, now, now)
			.run();

		return c.json(
			{
				id: agentId,
				user_id: userId,
				name: body.name.trim(),
				persona,
				status,
				created_at: now,
			},
			201,
		);
	} catch (error) {
		console.error("Failed to create agent:", error);
		return handleDatabaseError(c, error);
	}
});

// ============================================================================
// GET /api/agents - List user's agents
// ============================================================================

const listAgentsRoute = createRoute({
	method: "get",
	path: "/",
	tags: ["Agents"],
	summary: "List user's agents",
	description: "Get a list of all agents owned by the authenticated user",
	security: [{ bearerAuth: [] }],
	responses: {
		200: {
			description: "List of agents",
			content: {
				"application/json": {
					schema: ListAgentsResponseSchema,
				},
			},
		},
		401: {
			description: "Unauthorized",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		500: {
			description: "Internal server error",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
	},
});

agents.openapi(listAgentsRoute, async (c) => {
	const userId = getAuthUserId(c);

	try {
		const result = await c.env.DB.prepare(
			`SELECT a.id, a.user_id, a.name, a.persona, a.status, a.created_at, a.updated_at,
        COALESCE(asc_count.active_count, 0) as active_session_count
       FROM agents a
       LEFT JOIN (
         SELECT sp.agent_id, COUNT(*) as active_count
         FROM session_participants sp
         JOIN sessions s ON sp.session_id = s.id
         WHERE s.status = 'active'
         GROUP BY sp.agent_id
       ) asc_count ON a.id = asc_count.agent_id
       WHERE a.user_id = ?
       ORDER BY a.created_at DESC`,
		)
			.bind(userId)
			.all<Agent & { active_session_count: number }>();

		const agentsWithPersona = result.results.map((agent) => {
			const parsed = parseAgentPersona(agent);
			return {
				id: parsed.id,
				name: parsed.name,
				persona: parsed.persona,
				status: agent.status,
				active_session_count: agent.active_session_count,
				created_at: parsed.created_at,
			};
		});

		return c.json({
			agents: agentsWithPersona,
		});
	} catch (error) {
		return handleDatabaseError(c, error);
	}
});

// ============================================================================
// GET /api/agents/:id - Get agent details
// ============================================================================

const getAgentRoute = createRoute({
	method: "get",
	path: "/{id}",
	tags: ["Agents"],
	summary: "Get agent details",
	description: "Get detailed information about a specific agent",
	security: [{ bearerAuth: [] }],
	request: {
		params: z.object({
			id: z
				.string()
				.uuid()
				.openapi({
					param: {
						name: "id",
						in: "path",
					},
					description: "Agent ID",
					example: "123e4567-e89b-12d3-a456-426614174000",
				}),
		}),
	},
	responses: {
		200: {
			description: "Agent details",
			content: {
				"application/json": {
					schema: GetAgentResponseSchema,
				},
			},
		},
		401: {
			description: "Unauthorized",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		403: {
			description: "Forbidden - Agent belongs to another user",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		404: {
			description: "Agent not found",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		500: {
			description: "Internal server error",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
	},
});

agents.openapi(getAgentRoute, async (c) => {
	const userId = getAuthUserId(c);
	const agentId = c.req.param("id");

	try {
		const agent = await c.env.DB.prepare(
			`SELECT id, user_id, name, persona, status, created_at, updated_at
       FROM agents
       WHERE id = ?`,
		)
			.bind(agentId)
			.first<Agent>();

		if (!agent) {
			return notFound(c, "Agent");
		}

		// Check ownership
		if (agent.user_id !== userId) {
			return forbidden(c, "You do not have access to this agent");
		}

		const parsed = parseAgentPersona(agent);

		return c.json({
			id: parsed.id,
			user_id: parsed.user_id,
			name: parsed.name,
			persona: parsed.persona,
			status: agent.status,
			created_at: parsed.created_at,
			updated_at: parsed.updated_at,
		});
	} catch (error) {
		return handleDatabaseError(c, error);
	}
});

// ============================================================================
// PATCH /api/agents/:id - Update agent
// ============================================================================

const updateAgentRoute = createRoute({
	method: "patch",
	path: "/{id}",
	tags: ["Agents"],
	summary: "Update agent",
	description: "Update agent information (currently only name can be updated)",
	security: [{ bearerAuth: [] }],
	request: {
		params: z.object({
			id: z
				.string()
				.uuid()
				.openapi({
					param: {
						name: "id",
						in: "path",
					},
					description: "Agent ID",
					example: "123e4567-e89b-12d3-a456-426614174000",
				}),
		}),
		body: {
			content: {
				"application/json": {
					schema: UpdateAgentRequestSchema,
				},
			},
		},
	},
	responses: {
		200: {
			description: "Agent updated successfully",
			content: {
				"application/json": {
					schema: UpdateAgentResponseSchema,
				},
			},
		},
		400: {
			description: "Validation error",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		401: {
			description: "Unauthorized",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		403: {
			description: "Forbidden - Agent belongs to another user",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		404: {
			description: "Agent not found",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		500: {
			description: "Internal server error",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
	},
});

agents.openapi(updateAgentRoute, async (c) => {
	const userId = getAuthUserId(c);
	const agentId = c.req.param("id");
	const body = c.req.valid("json");

	try {
		// Check if agent exists and user owns it
		const agent = await c.env.DB.prepare(
			"SELECT id, user_id, name, persona, created_at, updated_at FROM agents WHERE id = ?",
		)
			.bind(agentId)
			.first<Agent>();

		if (!agent) {
			return notFound(c, "Agent");
		}

		if (agent.user_id !== userId) {
			return forbidden(c, "You do not have access to this agent");
		}

		// Update agent
		const now = getCurrentTimestamp();
		const newName = body.name?.trim() ?? agent.name;

		await c.env.DB.prepare("UPDATE agents SET name = ?, updated_at = ? WHERE id = ?")
			.bind(newName, now, agentId)
			.run();

		const parsed = parseAgentPersona(agent);

		return c.json({
			id: parsed.id,
			user_id: parsed.user_id,
			name: newName,
			persona: parsed.persona,
			updated_at: now,
		});
	} catch (error) {
		return handleDatabaseError(c, error);
	}
});

// ============================================================================
// PATCH /api/agents/:id/status - Update agent status
// ============================================================================

const updateAgentStatusRoute = createRoute({
	method: "patch",
	path: "/{id}/status",
	tags: ["Agents"],
	summary: "Update agent status",
	description:
		"Change agent status between active (participates in deliberations) and reserve (training only)",
	security: [{ bearerAuth: [] }],
	request: {
		params: z.object({
			id: z
				.string()
				.uuid()
				.openapi({
					param: {
						name: "id",
						in: "path",
					},
					description: "Agent ID",
					example: "123e4567-e89b-12d3-a456-426614174000",
				}),
		}),
		body: {
			content: {
				"application/json": {
					schema: UpdateAgentStatusRequestSchema,
				},
			},
		},
	},
	responses: {
		200: {
			description: "Agent status updated successfully",
			content: {
				"application/json": {
					schema: UpdateAgentStatusResponseSchema,
				},
			},
		},
		400: {
			description: "Validation error",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		401: {
			description: "Unauthorized",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		403: {
			description: "Forbidden - Agent belongs to another user",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		404: {
			description: "Agent not found",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		409: {
			description: "Conflict - Cannot change status due to constraints",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		500: {
			description: "Internal server error",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
	},
});

agents.openapi(updateAgentStatusRoute, async (c) => {
	const userId = getAuthUserId(c);
	const agentId = c.req.param("id");
	const body = c.req.valid("json");

	try {
		const agent = await c.env.DB.prepare("SELECT id, user_id, status FROM agents WHERE id = ?")
			.bind(agentId)
			.first<{ id: string; user_id: string; status: AgentStatus }>();

		if (!agent) {
			return notFound(c, "Agent");
		}

		if (agent.user_id !== userId) {
			return forbidden(c, "You do not have access to this agent");
		}

		if (agent.status === body.status) {
			const now = getCurrentTimestamp();
			return c.json({ id: agent.id, status: agent.status, updated_at: now });
		}

		if (body.status === "active") {
			// Check active slot availability
			const activeCountResult = await c.env.DB.prepare(
				"SELECT COUNT(*) as count FROM agents WHERE user_id = ? AND status = 'active'",
			)
				.bind(userId)
				.first<{ count: number }>();
			const activeCount = activeCountResult?.count ?? 0;
			if (activeCount >= MAX_ACTIVE_AGENTS_PER_USER) {
				return conflict(
					c,
					`アクティブスロットに空きがありません（最大${MAX_ACTIVE_AGENTS_PER_USER}体）`,
				);
			}
		} else {
			// Check if agent is in an active/pending session
			const sessionResult = await c.env.DB.prepare(
				`SELECT COUNT(*) as count FROM session_participants sp
         JOIN sessions s ON sp.session_id = s.id
         WHERE sp.agent_id = ? AND s.status IN ('pending', 'active')`,
			)
				.bind(agentId)
				.first<{ count: number }>();
			if (sessionResult && sessionResult.count > 0) {
				return conflict(c, "セッション参加中のエージェントはリザーブに移動できません");
			}
		}

		const now = getCurrentTimestamp();
		await c.env.DB.prepare("UPDATE agents SET status = ?, updated_at = ? WHERE id = ?")
			.bind(body.status, now, agentId)
			.run();

		return c.json({ id: agent.id, status: body.status, updated_at: now });
	} catch (error) {
		return handleDatabaseError(c, error);
	}
});

// ============================================================================
// DELETE /api/agents/:id - Delete agent
// ============================================================================

const deleteAgentRoute = createRoute({
	method: "delete",
	path: "/{id}",
	tags: ["Agents"],
	summary: "Delete agent",
	description: "Delete an agent and all related data (knowledge, inputs, etc.)",
	security: [{ bearerAuth: [] }],
	request: {
		params: z.object({
			id: z
				.string()
				.uuid()
				.openapi({
					param: {
						name: "id",
						in: "path",
					},
					description: "Agent ID",
					example: "123e4567-e89b-12d3-a456-426614174000",
				}),
		}),
	},
	responses: {
		200: {
			description: "Agent deleted successfully",
			content: {
				"application/json": {
					schema: SuccessResponseSchema,
				},
			},
		},
		401: {
			description: "Unauthorized",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		403: {
			description: "Forbidden - Agent belongs to another user",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		404: {
			description: "Agent not found",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		500: {
			description: "Internal server error",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
	},
});

agents.openapi(deleteAgentRoute, async (c) => {
	const userId = getAuthUserId(c);
	const agentId = c.req.param("id");

	try {
		// Check if agent exists and user owns it
		const agent = await c.env.DB.prepare("SELECT user_id FROM agents WHERE id = ?")
			.bind(agentId)
			.first<{ user_id: string }>();

		if (!agent) {
			return notFound(c, "Agent");
		}

		if (agent.user_id !== userId) {
			return forbidden(c, "You do not have access to this agent");
		}

		// Delete agent (cascade will delete related records)
		await c.env.DB.prepare("DELETE FROM agents WHERE id = ?").bind(agentId).run();

		return c.json({ success: true, message: "Agent deleted successfully" });
	} catch (error) {
		return handleDatabaseError(c, error);
	}
});

export { agents as agentsRouter };
