/**
 * Agent management API routes (OpenAPI)
 */

import { createRoute, OpenAPIHono, z } from "@hono/zod-openapi";
import { clerkAuth, getAuthUserId } from "../middleware/clerk-auth";
import {
	CreateAgentRequestSchema,
	CreateAgentResponseSchema,
	GetAgentResponseSchema,
	ListAgentsResponseSchema,
	UpdateAgentRequestSchema,
	UpdateAgentResponseSchema,
} from "../schemas/agents";
import { ErrorResponseSchema, SuccessResponseSchema } from "../schemas/common";
import { generateInitialPersona } from "../services/anthropic";
import type { Bindings } from "../types/bindings";
import type { Agent } from "../types/database";
import { getOrCreateUser, parseAgentPersona, stringifyAgentPersona } from "../utils/database";
import { forbidden, handleDatabaseError, notFound } from "../utils/errors";
import { getCurrentTimestamp } from "../utils/timestamp";
import { generateUUID } from "../utils/uuid";

const agents = new OpenAPIHono<{ Bindings: Bindings }>();

// Apply authentication to all routes
agents.use("/*", clerkAuth);

// ============================================================================
// POST /api/agents - Create new agent
// ============================================================================

const createAgentRoute = createRoute({
	method: "post",
	path: "/",
	tags: ["Agents"],
	summary: "Create a new agent",
	description: "Create a new AI agent with an initial persona generated by LLM",
	security: [{ bearerAuth: [] }],
	request: {
		body: {
			content: {
				"application/json": {
					schema: CreateAgentRequestSchema,
				},
			},
		},
	},
	responses: {
		201: {
			description: "Agent created successfully",
			content: {
				"application/json": {
					schema: CreateAgentResponseSchema,
				},
			},
		},
		400: {
			description: "Validation error",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		401: {
			description: "Unauthorized",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		500: {
			description: "Internal server error",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
	},
});

agents.openapi(createAgentRoute, async (c) => {
	const userId = getAuthUserId(c);
	const body = c.req.valid("json");

	console.log("Create agent request body:", JSON.stringify(body));

	try {
		// Ensure user exists in database
		await getOrCreateUser(c.env.DB, userId);

		// Generate initial persona using LLM
		const persona = await generateInitialPersona(c.env, body.name.trim());

		// Create agent
		const agentId = generateUUID();
		const now = getCurrentTimestamp();

		await c.env.DB.prepare(
			`INSERT INTO agents (id, user_id, name, persona, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?)`,
		)
			.bind(agentId, userId, body.name.trim(), stringifyAgentPersona(persona), now, now)
			.run();

		return c.json(
			{
				id: agentId,
				user_id: userId,
				name: body.name.trim(),
				persona,
				created_at: now,
			},
			201,
		);
	} catch (error) {
		console.error("Failed to create agent:", error);
		return handleDatabaseError(c, error);
	}
});

// ============================================================================
// GET /api/agents - List user's agents
// ============================================================================

const listAgentsRoute = createRoute({
	method: "get",
	path: "/",
	tags: ["Agents"],
	summary: "List user's agents",
	description: "Get a list of all agents owned by the authenticated user",
	security: [{ bearerAuth: [] }],
	responses: {
		200: {
			description: "List of agents",
			content: {
				"application/json": {
					schema: ListAgentsResponseSchema,
				},
			},
		},
		401: {
			description: "Unauthorized",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		500: {
			description: "Internal server error",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
	},
});

agents.openapi(listAgentsRoute, async (c) => {
	const userId = getAuthUserId(c);

	try {
		const result = await c.env.DB.prepare(
			`SELECT id, user_id, name, persona, created_at, updated_at
       FROM agents
       WHERE user_id = ?
       ORDER BY created_at DESC`,
		)
			.bind(userId)
			.all<Agent>();

		const agentsWithPersona = result.results.map((agent) => {
			const parsed = parseAgentPersona(agent);
			return {
				id: parsed.id,
				name: parsed.name,
				persona: parsed.persona,
				created_at: parsed.created_at,
			};
		});

		return c.json({
			agents: agentsWithPersona,
		});
	} catch (error) {
		return handleDatabaseError(c, error);
	}
});

// ============================================================================
// GET /api/agents/:id - Get agent details
// ============================================================================

const getAgentRoute = createRoute({
	method: "get",
	path: "/{id}",
	tags: ["Agents"],
	summary: "Get agent details",
	description: "Get detailed information about a specific agent",
	security: [{ bearerAuth: [] }],
	request: {
		params: z.object({
			id: z
				.string()
				.uuid()
				.openapi({
					param: {
						name: "id",
						in: "path",
					},
					description: "Agent ID",
					example: "123e4567-e89b-12d3-a456-426614174000",
				}),
		}),
	},
	responses: {
		200: {
			description: "Agent details",
			content: {
				"application/json": {
					schema: GetAgentResponseSchema,
				},
			},
		},
		401: {
			description: "Unauthorized",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		403: {
			description: "Forbidden - Agent belongs to another user",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		404: {
			description: "Agent not found",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		500: {
			description: "Internal server error",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
	},
});

agents.openapi(getAgentRoute, async (c) => {
	const userId = getAuthUserId(c);
	const agentId = c.req.param("id");

	try {
		const agent = await c.env.DB.prepare(
			`SELECT id, user_id, name, persona, created_at, updated_at
       FROM agents
       WHERE id = ?`,
		)
			.bind(agentId)
			.first<Agent>();

		if (!agent) {
			return notFound(c, "Agent");
		}

		// Check ownership
		if (agent.user_id !== userId) {
			return forbidden(c, "You do not have access to this agent");
		}

		const parsed = parseAgentPersona(agent);

		return c.json({
			id: parsed.id,
			user_id: parsed.user_id,
			name: parsed.name,
			persona: parsed.persona,
			created_at: parsed.created_at,
			updated_at: parsed.updated_at,
		});
	} catch (error) {
		return handleDatabaseError(c, error);
	}
});

// ============================================================================
// PATCH /api/agents/:id - Update agent
// ============================================================================

const updateAgentRoute = createRoute({
	method: "patch",
	path: "/{id}",
	tags: ["Agents"],
	summary: "Update agent",
	description: "Update agent information (currently only name can be updated)",
	security: [{ bearerAuth: [] }],
	request: {
		params: z.object({
			id: z
				.string()
				.uuid()
				.openapi({
					param: {
						name: "id",
						in: "path",
					},
					description: "Agent ID",
					example: "123e4567-e89b-12d3-a456-426614174000",
				}),
		}),
		body: {
			content: {
				"application/json": {
					schema: UpdateAgentRequestSchema,
				},
			},
		},
	},
	responses: {
		200: {
			description: "Agent updated successfully",
			content: {
				"application/json": {
					schema: UpdateAgentResponseSchema,
				},
			},
		},
		400: {
			description: "Validation error",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		401: {
			description: "Unauthorized",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		403: {
			description: "Forbidden - Agent belongs to another user",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		404: {
			description: "Agent not found",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		500: {
			description: "Internal server error",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
	},
});

agents.openapi(updateAgentRoute, async (c) => {
	const userId = getAuthUserId(c);
	const agentId = c.req.param("id");
	const body = c.req.valid("json");

	try {
		// Check if agent exists and user owns it
		const agent = await c.env.DB.prepare(
			"SELECT id, user_id, name, persona, created_at, updated_at FROM agents WHERE id = ?",
		)
			.bind(agentId)
			.first<Agent>();

		if (!agent) {
			return notFound(c, "Agent");
		}

		if (agent.user_id !== userId) {
			return forbidden(c, "You do not have access to this agent");
		}

		// Update agent
		const now = getCurrentTimestamp();
		const newName = body.name?.trim() ?? agent.name;

		await c.env.DB.prepare("UPDATE agents SET name = ?, updated_at = ? WHERE id = ?")
			.bind(newName, now, agentId)
			.run();

		const parsed = parseAgentPersona(agent);

		return c.json({
			id: parsed.id,
			user_id: parsed.user_id,
			name: newName,
			persona: parsed.persona,
			updated_at: now,
		});
	} catch (error) {
		return handleDatabaseError(c, error);
	}
});

// ============================================================================
// DELETE /api/agents/:id - Delete agent
// ============================================================================

const deleteAgentRoute = createRoute({
	method: "delete",
	path: "/{id}",
	tags: ["Agents"],
	summary: "Delete agent",
	description: "Delete an agent and all related data (knowledge, inputs, etc.)",
	security: [{ bearerAuth: [] }],
	request: {
		params: z.object({
			id: z
				.string()
				.uuid()
				.openapi({
					param: {
						name: "id",
						in: "path",
					},
					description: "Agent ID",
					example: "123e4567-e89b-12d3-a456-426614174000",
				}),
		}),
	},
	responses: {
		200: {
			description: "Agent deleted successfully",
			content: {
				"application/json": {
					schema: SuccessResponseSchema,
				},
			},
		},
		401: {
			description: "Unauthorized",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		403: {
			description: "Forbidden - Agent belongs to another user",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		404: {
			description: "Agent not found",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
		500: {
			description: "Internal server error",
			content: {
				"application/json": {
					schema: ErrorResponseSchema,
				},
			},
		},
	},
});

agents.openapi(deleteAgentRoute, async (c) => {
	const userId = getAuthUserId(c);
	const agentId = c.req.param("id");

	try {
		// Check if agent exists and user owns it
		const agent = await c.env.DB.prepare("SELECT user_id FROM agents WHERE id = ?")
			.bind(agentId)
			.first<{ user_id: string }>();

		if (!agent) {
			return notFound(c, "Agent");
		}

		if (agent.user_id !== userId) {
			return forbidden(c, "You do not have access to this agent");
		}

		// Delete agent (cascade will delete related records)
		await c.env.DB.prepare("DELETE FROM agents WHERE id = ?").bind(agentId).run();

		return c.json({ success: true, message: "Agent deleted successfully" });
	} catch (error) {
		return handleDatabaseError(c, error);
	}
});

export { agents as agentsRouter };
